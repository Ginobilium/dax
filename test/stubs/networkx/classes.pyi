import typing

__all__ = ['Graph', 'DiGraph']

_N_T = typing.TypeVar('_N_T')  # Generic type for the node type of the graph


class Graph(typing.Generic[_N_T]):
    node_dict_factory: type = ...
    node_attr_dict_factory: type = ...
    adjlist_outer_dict_factory: type = ...
    adjlist_inner_dict_factory: type = ...
    edge_attr_dict_factory: type = ...
    graph_attr_dict_factory: type = ...

    def to_directed_class(self) -> type:
        ...

    def to_undirected_class(self) -> type:
        ...

    def __init__(self, incoming_graph_data: typing.Any = ..., **attr: typing.Any):
        ...

    @property
    def name(self) -> str:
        ...

    @name.setter
    def name(self, s: str) -> None:
        ...

    def __str__(self) -> str:
        ...

    def __iter__(self) -> typing.Iterator[_N_T]:
        ...

    def __contains__(self, n: _N_T) -> bool:
        ...

    def __len__(self) -> int:
        ...

    def add_node(self, node_for_adding: _N_T, **attr: typing.Any) -> None:
        ...

    def add_nodes_from(self, nodes_for_adding: typing.Iterable[_N_T], **attr: typing.Any) -> None:
        ...

    def remove_node(self, n: _N_T) -> None:
        ...

    def remove_nodes_from(self, nodes: typing.Iterable[_N_T]) -> None:
        ...

    def number_of_nodes(self) -> int:
        ...

    def order(self) -> int:
        ...

    def has_node(self, n: _N_T) -> bool:
        ...

    def add_edge(self, u_of_edge: _N_T, v_of_edge: _N_T, **attr: typing.Any) -> None:
        ...

    def add_edges_from(self, ebunch_to_add: typing.Iterable[typing.Tuple[_N_T, _N_T]], **attr: typing.Any) -> None:
        ...

    def remove_edge(self, u: _N_T, v: _N_T) -> None:
        ...

    def remove_edges_from(self, ebunch: typing.Iterable[typing.Tuple[_N_T, _N_T]]) -> None:
        ...

    def has_edge(self, u: _N_T, v: _N_T) -> bool:
        ...

    @property
    def edges(self) -> typing.Iterator[typing.Tuple[_N_T, _N_T]]:
        ...

    @property
    def degree(self) -> typing.Dict[_N_T, int]:
        ...

    def clear(self) -> None:
        ...

    def is_multigraph(self) -> bool:
        ...

    def is_directed(self) -> bool:
        ...


class DiGraph(Graph, typing.Generic[_N_T]):

    def __init__(self, incoming_graph_data: typing.Any = ..., **attr: typing.Any):
        ...

    def has_successor(self, u: _N_T, v: _N_T) -> bool:
        ...

    def has_predecessor(self, u: _N_T, v: _N_T) -> bool:
        ...

    def successors(self, n: _N_T) -> typing.Iterator[_N_T]:
        ...

    neighbors = successors

    def predecessors(self, n: _N_T) -> typing.Iterator[_N_T]:
        ...

    @property
    def in_edges(self) -> typing.Iterator[typing.Tuple[_N_T, _N_T]]:
        ...

    @property
    def in_degree(self) -> typing.Iterator[typing.Tuple[_N_T, int]]:
        ...

    @property
    def out_degree(self) -> typing.Iterator[typing.Tuple[_N_T, int]]:
        ...

    def reverse(self, copy: bool = ...) -> DiGraph:
        ...
